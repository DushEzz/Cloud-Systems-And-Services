# Лабораторная работа №1

## Цель работы
Написать два Dockerfile – плохой (не менее трех ошибок) и хороший, а также привести две плохие практики по 
использованию образа (то есть создания контейнера).

## Задачи
1. Написать "плохой" Dockerfile, то есть тот, который был спроектирован неверно, но при этом корректно бы запускался
2. Написать "хороший" Dockerfile, в котором все ошибки будут исправлены
3. Описать все плохие практики, объяснить, почему они являются таковыми
4. Привести пример двух плохих практик по использованию этого контейнера.

## Описание проекта, для которого были созданы Dockerfile'ы
Два Dockerfile предназначены для **Python-проекта** (проект абстрактный, потому что его код не имеет никакого значения
в контексте данной работы), который может запускаться с разными флагами и разными способами. 
Данный проект использует сторонние библиотеки, и все файлы, находящиеся в корне проекта, 
должны быть перенесены в контейнер.

## "Плохой" Dockerfile
Ниже приведены все ошибки в "плохом" Dockerfile, а также их описание (в разделе про "хороший" Dockerfile). 
Как выглядит этот Dockerfile:
```
FROM ubuntu:latest

RUN mkdir src &&
    cd src
WORKDIR /src

RUN apt-get update
RUN apt-get install -y python3

COPY . /src
RUN pip install -r requirements.txt
```

### Размер итогового образа
Родительский образ (`FROM ubuntu:latest`) представляет собой полноценную операционную систему 
с большим количеством ненужных зависимостей, пакетов и так далее. Это же и относится к командам, выполненных с `apt-get`,
так как помимо Python в него  

### Выбор версии
Не следует указывать версию `latest` у родительского образа, так как она является "плавающей", и при выходе новой \
версии образа проект может "сломаться"

### Неотптизизированные операции
При изменении кода проекта и пересбоорке образа будет постоянно производиться 
установка сторонних библиотек из requirements.txt. Это происходит потому, что сборка образа начнется с первого слоя, 
хэш которого был изменен. При изменении кода в проекте сборка начнется с этапа `COPY . /src`, что означает, 
что `RUN pip install -r requirements.txt` будет выполняться всегда, а этого можно избежать.

### Лишние операции (слои, которых могло не быть)
Некоторые действия можно опустить, так как их автоматически выполняют другие операции. Так, здесь можно убрать `RUN mkdir src && cd src`

### Отсутствие команды запуска проекта
Это значит, что ее обязательно нужно будет указывать в команде `docker run` после флага `-c`. Это может быть неудобно 
при запуске контейнера, а также привести к ошибкам (если, например, команда длинная или она была вовсе не введена)

## "Хороший" Dockerfile
Как выглядит этот Dockerfile:
```
FROM ubuntu:latest

RUN mkdir src &&
    cd src
WORKDIR /src

RUN apt-get update
RUN apt-get install -y python3

COPY . /src
RUN pip install -r requirements.txt
```
Ниже приведен список изменений, исправляющие вышеупомянутые ошибки:
1. Был _изменен родительский образ_ (`FROM python:3.9-alpine`), который содержит все только все необходимое для сборки 
и запуска проекта
2. Версия родительского образа статическая, а не `latest`
3. Теперь файл с зависимостями копируется отдельно, чтобы, когда появятся изменения в них, 
только тогда они будут устанавливаться
4. _Убрана операция_ создания рабочей папки
5. _Добавление команды по умолчанию_ с помощью связки `ENTRYPOINT` и `CMD`

### Плохие практики по использованию этого контейнера
- При запуске контейнера (без помощи `docker-compose`) важно указать флаг `-v`, чтобы иметь локальную копию данных, 
предназначенные для базы данных. Иначе при потере контейнера с БД все данные будут утеряны навсегда
- Использование команды `docker stop` вместо `docker kill` для остановки контейнера, который не отвечает - это
может привести к длительному ожиданию завершения процессов в контейнере и замедлению работы системы
- Использование команды `docker run` с флагом `--privileged` - это может дать контейнеру полный доступ к хост-системе 
и привести к потенциальным уязвимостям безопасности

## Вывод
В ходе данной работы мы написали два Dockerfile'а с достаточным количеством ошибок и соответствующим им исправлениям. 
Каждая ошибка была подробно описана и аргументирована, как и исправления к каждой из них. Помимо этого, мы привели 
три из большого количества плохих практик использования CLI docker
